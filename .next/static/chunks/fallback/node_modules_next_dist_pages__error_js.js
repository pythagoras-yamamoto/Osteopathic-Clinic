"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_next_dist_pages__error_js"],{

/***/ "./node_modules/next/dist/pages/_error.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/pages/_error.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\n\nvar _classCallCheck = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/createClass.js\");\n\nvar _inherits = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/inherits.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/inherits.js\");\n\nvar _possibleConstructorReturn = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/possibleConstructorReturn.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/possibleConstructorReturn.js\");\n\nvar _getPrototypeOf = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/getPrototypeOf.js */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/getPrototypeOf.js\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _head = _interopRequireDefault(__webpack_require__(/*! ../shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar statusCodes = {\n  400: 'Bad Request',\n  404: 'This page could not be found',\n  405: 'Method Not Allowed',\n  500: 'Internal Server Error'\n};\n\nfunction _getInitialProps(_ref) {\n  var res = _ref.res,\n      err = _ref.err;\n  var statusCode = res && res.statusCode ? res.statusCode : err ? err.statusCode : 404;\n  return {\n    statusCode: statusCode\n  };\n}\n\nvar _Component;\n\nvar Error = /*#__PURE__*/function (_Component2) {\n  _inherits(Error, _Component2);\n\n  var _super = _createSuper(Error);\n\n  function Error() {\n    _classCallCheck(this, Error);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Error, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          statusCode = _this$props.statusCode,\n          _this$props$withDarkM = _this$props.withDarkMode,\n          withDarkMode = _this$props$withDarkM === void 0 ? true : _this$props$withDarkM;\n      var title = this.props.title || statusCodes[statusCode] || 'An unexpected error has occurred';\n      return /*#__PURE__*/_react.default.createElement(\"div\", {\n        style: styles.error\n      }, /*#__PURE__*/_react.default.createElement(_head.default, null, /*#__PURE__*/_react.default.createElement(\"title\", null, statusCode ? \"\".concat(statusCode, \": \").concat(title) : 'Application error: a client-side exception has occurred')), /*#__PURE__*/_react.default.createElement(\"div\", null, /*#__PURE__*/_react.default.createElement(\"style\", {\n        dangerouslySetInnerHTML: {\n          __html: \"\\n                body { margin: 0; color: #000; background: #fff; }\\n                .next-error-h1 {\\n                  border-right: 1px solid rgba(0, 0, 0, .3);\\n                }\\n                \\n                \".concat(withDarkMode ? \"@media (prefers-color-scheme: dark) {\\n                  body { color: #fff; background: #000; }\\n                  .next-error-h1 {\\n                    border-right: 1px solid rgba(255, 255, 255, .3);\\n                  }\\n                }\" : '')\n        }\n      }), statusCode ? /*#__PURE__*/_react.default.createElement(\"h1\", {\n        className: \"next-error-h1\",\n        style: styles.h1\n      }, statusCode) : null, /*#__PURE__*/_react.default.createElement(\"div\", {\n        style: styles.desc\n      }, /*#__PURE__*/_react.default.createElement(\"h2\", {\n        style: styles.h2\n      }, this.props.title || statusCode ? title : /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, \"Application error: a client-side exception has occurred (see the browser console for more information)\"), \".\"))));\n    }\n  }]);\n\n  return Error;\n}(_Component = _react.default.Component);\n\nError.displayName = 'ErrorPage';\nError.getInitialProps = _getInitialProps;\nError.origGetInitialProps = _getInitialProps;\nvar styles = {\n  error: {\n    fontFamily: '-apple-system, BlinkMacSystemFont, Roboto, \"Segoe UI\", \"Fira Sans\", Avenir, \"Helvetica Neue\", \"Lucida Grande\", sans-serif',\n    height: '100vh',\n    textAlign: 'center',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n    justifyContent: 'center'\n  },\n  desc: {\n    display: 'inline-block',\n    textAlign: 'left',\n    lineHeight: '49px',\n    height: '49px',\n    verticalAlign: 'middle'\n  },\n  h1: {\n    display: 'inline-block',\n    margin: 0,\n    marginRight: '20px',\n    padding: '10px 23px 10px 0',\n    fontSize: '24px',\n    fontWeight: 500,\n    verticalAlign: 'top'\n  },\n  h2: {\n    fontSize: '14px',\n    fontWeight: 'normal',\n    lineHeight: 'inherit',\n    margin: 0,\n    padding: 0\n  }\n};\nexports[\"default\"] = Error;\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3BhZ2VzL19lcnJvci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7Ozs7Ozs7Ozs7Ozs7OztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3QztBQUdBRCxrQkFBQSxHQUFrQixLQUFLLENBQXZCOztBQUNBLElBQUlHLE1BQU0sR0FBR0Msc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsNENBQUQsQ0FBUixDQUFuQzs7QUFDQSxJQUFJQyxLQUFLLEdBQUdGLHNCQUFzQixDQUFDQyxtQkFBTyxDQUFDLHVFQUFELENBQVIsQ0FBbEM7O0FBQ0EsU0FBU0Qsc0JBQVQsQ0FBZ0NHLEdBQWhDLEVBQXFDO0VBQ2pDLE9BQU9BLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFYLEdBQXdCRCxHQUF4QixHQUE4QjtJQUNqQ0wsT0FBTyxFQUFFSztFQUR3QixDQUFyQztBQUdIOztBQUNELElBQU1FLFdBQVcsR0FBRztFQUNoQixLQUFLLGFBRFc7RUFFaEIsS0FBSyw4QkFGVztFQUdoQixLQUFLLG9CQUhXO0VBSWhCLEtBQUs7QUFKVyxDQUFwQjs7QUFNQSxTQUFTQyxnQkFBVCxPQUEwQztFQUFBLElBQWRDLEdBQWMsUUFBZEEsR0FBYztFQUFBLElBQVJDLEdBQVEsUUFBUkEsR0FBUTtFQUN0QyxJQUFNQyxVQUFVLEdBQUdGLEdBQUcsSUFBSUEsR0FBRyxDQUFDRSxVQUFYLEdBQXdCRixHQUFHLENBQUNFLFVBQTVCLEdBQXlDRCxHQUFHLEdBQUdBLEdBQUcsQ0FBQ0MsVUFBUCxHQUFvQixHQUFuRjtFQUNBLE9BQU87SUFDSEEsVUFBVSxFQUFWQTtFQURHLENBQVA7QUFHSDs7QUFDRCxJQUFJQyxVQUFKOztJQUNNQyxLOzs7Ozs7Ozs7Ozs7O1dBQ0Ysa0JBQVM7TUFDTCxrQkFBNkMsS0FBS0MsS0FBbEQ7TUFBQSxJQUFRSCxVQUFSLGVBQVFBLFVBQVI7TUFBQSx3Q0FBcUJJLFlBQXJCO01BQUEsSUFBcUJBLFlBQXJCLHND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QWEsRUFBRTtFQVBmLENBakJPO0VBMEJYZCxFQUFFLEVBQUU7SUFDQWtCLFFBQVEsRUFBRSxNQURWO0lBRUFDLFVBQVUsRUFBRSxRQUZaO0lBR0FOLFVBQVUsRUFBRSxTQUhaO0lBSUFFLE1BQU0sRUFBRSxDQUpSO0lBS0FFLE9BQU8sRUFBRTtFQUxUO0FBMUJPLENBQWY7QUFrQ0E3QyxrQkFBQSxHQUFrQmUsS0FBbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9wYWdlcy9fZXJyb3IuanM/MThmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2hlYWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2hlYWRcIikpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuY29uc3Qgc3RhdHVzQ29kZXMgPSB7XG4gICAgNDAwOiAnQmFkIFJlcXVlc3QnLFxuICAgIDQwNDogJ1RoaXMgcGFnZSBjb3VsZCBub3QgYmUgZm91bmQnLFxuICAgIDQwNTogJ01ldGhvZCBOb3QgQWxsb3dlZCcsXG4gICAgNTAwOiAnSW50ZXJuYWwgU2VydmVyIEVycm9yJ1xufTtcbmZ1bmN0aW9uIF9nZXRJbml0aWFsUHJvcHMoeyByZXMgLCBlcnIgIH0pIHtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzICYmIHJlcy5zdGF0dXNDb2RlID8gcmVzLnN0YXR1c0NvZGUgOiBlcnIgPyBlcnIuc3RhdHVzQ29kZSA6IDQwNDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXNDb2RlXG4gICAgfTtcbn1cbnZhciBfQ29tcG9uZW50O1xuY2xhc3MgRXJyb3IgZXh0ZW5kcyAoX0NvbXBvbmVudCA9IF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCkge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXNDb2RlICwgd2l0aERhcmtNb2RlID10cnVlICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgdGl0bGUgPSB0aGlzLnByb3BzLnRpdGxlIHx8IHN0YXR1c0NvZGVzW3N0YXR1c0NvZGVdIHx8ICdBbiB1bmV4cGVjdGVkIGVycm9yIGhhcyBvY2N1cnJlZCc7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgICAgc3R5bGU6IHN0eWxlcy5lcnJvclxuICAgICAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hlYWQuZGVmYXVsdCwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwgbnVsbCwgc3RhdHVzQ29kZSA/IGAke3N0YXR1c0NvZGV9OiAke3RpdGxlfWAgOiAnQXBwbGljYXRpb24gZXJyb3I6IGEgY2xpZW50LXNpZGUgZXhjZXB0aW9uIGhhcyBvY2N1cnJlZCcpKSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIsIHtcbiAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgICAgICAgICAgX19odG1sOiBgXG4gICAgICAgICAgICAgICAgYm9keSB7IG1hcmdpbjogMDsgY29sb3I6ICMwMDA7IGJhY2tncm91bmQ6ICNmZmY7IH1cbiAgICAgICAgICAgICAgICAubmV4dC1lcnJvci1oMSB7XG4gICAgICAgICAgICAgICAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCByZ2JhKDAsIDAsIDAsIC4zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgJHt3aXRoRGFya01vZGUgPyBgQG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaykge1xuICAgICAgICAgICAgICAgICAgYm9keSB7IGNvbG9yOiAjZmZmOyBiYWNrZ3JvdW5kOiAjMDAwOyB9XG4gICAgICAgICAgICAgICAgICAubmV4dC1lcnJvci1oMSB7XG4gICAgICAgICAgICAgICAgICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgLjMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1gIDogJyd9YFxuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgc3RhdHVzQ29kZSA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImgxXCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJuZXh0LWVycm9yLWgxXCIsXG4gICAgICAgICAgICBzdHlsZTogc3R5bGVzLmgxXG4gICAgICAgIH0sIHN0YXR1c0NvZGUpIDogbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZXMuZGVzY1xuICAgICAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJoMlwiLCB7XG4gICAgICAgICAgICBzdHlsZTogc3R5bGVzLmgyXG4gICAgICAgIH0sIHRoaXMucHJvcHMudGl0bGUgfHwgc3RhdHVzQ29kZSA/IHRpdGxlIDogLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBcIkFwcGxpY2F0aW9uIGVycm9yOiBhIGNsaWVudC1zaWRlIGV4Y2VwdGlvbiBoYXMgb2NjdXJyZWQgKHNlZSB0aGUgYnJvd3NlciBjb25zb2xlIGZvciBtb3JlIGluZm9ybWF0aW9uKVwiKSwgXCIuXCIpKSkpO1xuICAgIH1cbn1cbkVycm9yLmRpc3BsYXlOYW1lID0gJ0Vycm9yUGFnZSc7XG5FcnJvci5nZXRJbml0aWFsUHJvcHMgPSBfZ2V0SW5pdGlhbFByb3BzO1xuRXJyb3Iub3JpZ0dldEluaXRpYWxQcm9wcyA9IF9nZXRJbml0aWFsUHJvcHM7XG5jb25zdCBzdHlsZXMgPSB7XG4gICAgZXJyb3I6IHtcbiAgICAgICAgZm9udEZhbWlseTogJy1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgUm9ib3RvLCBcIlNlZ29lIFVJXCIsIFwiRmlyYSBTYW5zXCIsIEF2ZW5pciwgXCJIZWx2ZXRpY2EgTmV1ZVwiLCBcIkx1Y2lkYSBHcmFuZGVcIiwgc2Fucy1zZXJpZicsXG4gICAgICAgIGhlaWdodDogJzEwMHZoJyxcbiAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJ1xuICAgIH0sXG4gICAgZGVzYzoge1xuICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgdGV4dEFsaWduOiAnbGVmdCcsXG4gICAgICAgIGxpbmVIZWlnaHQ6ICc0OXB4JyxcbiAgICAgICAgaGVpZ2h0OiAnNDlweCcsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnXG4gICAgfSxcbiAgICBoMToge1xuICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBtYXJnaW5SaWdodDogJzIwcHgnLFxuICAgICAgICBwYWRkaW5nOiAnMTBweCAyM3B4IDEwcHggMCcsXG4gICAgICAgIGZvbnRTaXplOiAnMjRweCcsXG4gICAgICAgIGZvbnRXZWlnaHQ6IDUwMCxcbiAgICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCdcbiAgICB9LFxuICAgIGgyOiB7XG4gICAgICAgIGZvbnRTaXplOiAnMTRweCcsXG4gICAgICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuICAgICAgICBsaW5lSGVpZ2h0OiAnaW5oZXJpdCcsXG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgcGFkZGluZzogMFxuICAgIH1cbn07XG5leHBvcnRzLmRlZmF1bHQgPSBFcnJvcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Vycm9yLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9oZWFkIiwib2JqIiwiX19lc01vZHVsZSIsInN0YXR1c0NvZGVzIiwiX2dldEluaXRpYWxQcm9wcyIsInJlcyIsImVyciIsInN0YXR1c0NvZGUiLCJfQ29tcG9uZW50IiwiRXJyb3IiLCJwcm9wcyIsIndpdGhEYXJrTW9kZSIsInRpdGxlIiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwic3R5bGVzIiwiZXJyb3IiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCIsImNsYXNzTmFtZSIsImgxIiwiZGVzYyIsImgyIiwiRnJhZ21lbnQiLCJDb21wb25lbnQiLCJkaXNwbGF5TmFtZSIsImdldEluaXRpYWxQcm9wcyIsIm9yaWdHZXRJbml0aWFsUHJvcHMiLCJmb250RmFtaWx5IiwiaGVpZ2h0IiwidGV4dEFsaWduIiwiZGlzcGxheSIsImZsZXhEaXJlY3Rpb24iLCJhbGlnbkl0ZW1zIiwianVzdGlmeUNvbnRlbnQiLCJsaW5lSGVpZ2h0IiwidmVydGljYWxBbGlnbiIsIm1hcmdpbiIsIm1hcmdpblJpZ2h0IiwicGFkZGluZyIsImZvbnRTaXplIiwiZm9udFdlaWdodCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/pages/_error.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/amp-context.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-context.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AmpStateContext = void 0;\n\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar AmpStateContext = _react.default.createContext({});\n\nexports.AmpStateContext = AmpStateContext;\n\nif (true) {\n  AmpStateContext.displayName = 'AmpStateContext';\n}\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvYW1wLWNvbnRleHQuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDO0FBR0FELHVCQUFBLEdBQTBCLEtBQUssQ0FBL0I7O0FBQ0EsSUFBSUcsTUFBTSxHQUFHQyxzQkFBc0IsQ0FBQ0MsbUJBQU8sQ0FBQyw0Q0FBRCxDQUFSLENBQW5DOztBQUNBLFNBQVNELHNCQUFULENBQWdDRSxHQUFoQyxFQUFxQztFQUNqQyxPQUFPQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0MsVUFBWCxHQUF3QkQsR0FBeEIsR0FBOEI7SUFDakNFLE9BQU8sRUFBRUY7RUFEd0IsQ0FBckM7QUFHSDs7QUFDRCxJQUFNSixlQUFlLEdBQUdDLE1BQU0sQ0FBQ0ssT0FBUCxDQUFlQyxhQUFmLENBQTZCLEVBQTdCLENBQXhCOztBQUNBVCx1QkFBQSxHQUEwQkUsZUFBMUI7O0FBQ0EsSUFBSSxNQUF1QztFQUN2Q0EsZUFBZSxDQUFDUSxXQUFoQixHQUE4QixpQkFBOUI7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvYW1wLWNvbnRleHQuanM/ZTVhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQW1wU3RhdGVDb250ZXh0ID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbn1cbmNvbnN0IEFtcFN0YXRlQ29udGV4dCA9IF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUNvbnRleHQoe30pO1xuZXhwb3J0cy5BbXBTdGF0ZUNvbnRleHQgPSBBbXBTdGF0ZUNvbnRleHQ7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIEFtcFN0YXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdBbXBTdGF0ZUNvbnRleHQnO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbXAtY29udGV4dC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBbXBTdGF0ZUNvbnRleHQiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIm9iaiIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiY3JlYXRlQ29udGV4dCIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/amp-context.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/amp-mode.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-mode.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.isInAmpMode = isInAmpMode;\n\nfunction isInAmpMode() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$ampFirst = _ref.ampFirst,\n      ampFirst = _ref$ampFirst === void 0 ? false : _ref$ampFirst,\n      _ref$hybrid = _ref.hybrid,\n      hybrid = _ref$hybrid === void 0 ? false : _ref$hybrid,\n      _ref$hasQuery = _ref.hasQuery,\n      hasQuery = _ref$hasQuery === void 0 ? false : _ref$hasQuery;\n\n  return ampFirst || hybrid && hasQuery;\n}\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvYW1wLW1vZGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBRGtDLENBQTdDO0FBR0FELG1CQUFBLEdBQXNCRSxXQUF0Qjs7QUFDQSxTQUFTQSxXQUFULEdBQW9GO0VBQUEsK0VBQUosRUFBSTtFQUFBLHlCQUE3REMsUUFBNkQ7RUFBQSxJQUE3REEsUUFBNkQsOEJBQW5ELEtBQW1EO0VBQUEsdUJBQTNDQyxNQUEyQztFQUFBLElBQTNDQSxNQUEyQyw0QkFBbkMsS0FBbUM7RUFBQSx5QkFBM0JDLFFBQTJCO0VBQUEsSUFBM0JBLFFBQTJCLDhCQUFqQixLQUFpQjs7RUFDaEYsT0FBT0YsUUFBUSxJQUFJQyxNQUFNLElBQUlDLFFBQTdCO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2FtcC1tb2RlLmpzPzYyMzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzSW5BbXBNb2RlID0gaXNJbkFtcE1vZGU7XG5mdW5jdGlvbiBpc0luQW1wTW9kZSh7IGFtcEZpcnN0ID1mYWxzZSAsIGh5YnJpZCA9ZmFsc2UgLCBoYXNRdWVyeSA9ZmFsc2UgLCAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIGFtcEZpcnN0IHx8IGh5YnJpZCAmJiBoYXNRdWVyeTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW1wLW1vZGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaXNJbkFtcE1vZGUiLCJhbXBGaXJzdCIsImh5YnJpZCIsImhhc1F1ZXJ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/amp-mode.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/head.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/head.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\n\nvar _s = $RefreshSig$();\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.defaultHead = defaultHead;\nexports[\"default\"] = void 0;\n\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _sideEffect = _interopRequireDefault(__webpack_require__(/*! ./side-effect */ \"./node_modules/next/dist/shared/lib/side-effect.js\"));\n\nvar _ampContext = __webpack_require__(/*! ./amp-context */ \"./node_modules/next/dist/shared/lib/amp-context.js\");\n\nvar _headManagerContext = __webpack_require__(/*! ./head-manager-context */ \"./node_modules/next/dist/shared/lib/head-manager-context.js\");\n\nvar _ampMode = __webpack_require__(/*! ./amp-mode */ \"./node_modules/next/dist/shared/lib/amp-mode.js\");\n\nvar _utils = __webpack_require__(/*! ./utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction defaultHead() {\n  var inAmpMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var head = [/*#__PURE__*/_react.default.createElement(\"meta\", {\n    charSet: \"utf-8\"\n  })];\n\n  if (!inAmpMode) {\n    head.push( /*#__PURE__*/_react.default.createElement(\"meta\", {\n      name: \"viewport\",\n      content: \"width=device-width\"\n    }));\n  }\n\n  return head;\n}\n\nfunction onlyReactElement(list, child) {\n  // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n  if (typeof child === 'string' || typeof child === 'number') {\n    return list;\n  } // Adds support for React.Fragment\n\n\n  if (child.type === _react.default.Fragment) {\n    return list.concat(_react.default.Children.toArray(child.props.children).reduce(function (fragmentList, fragmentChild) {\n      if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {\n        return fragmentList;\n      }\n\n      return fragmentList.concat(fragmentChild);\n    }, []));\n  }\n\n  return list.concat(child);\n}\n\nvar METATYPES = ['name', 'httpEquiv', 'charSet', 'itemProp'];\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/\n\nfunction unique() {\n  var keys = new Set();\n  var tags = new Set();\n  var metaTypes = new Set();\n  var metaCategories = {};\n  return function (h) {\n    var isUnique = true;\n    var hasKey = false;\n\n    if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {\n      hasKey = true;\n      var key = h.key.slice(h.key.indexOf('$') + 1);\n\n      if (keys.has(key)) {\n        isUnique = false;\n      } else {\n        keys.add(key);\n      }\n    } // eslint-disable-next-line default-case\n\n\n    switch (h.type) {\n      case 'title':\n      case 'base':\n        if (tags.has(h.type)) {\n          isUnique = false;\n        } else {\n          tags.add(h.type);\n        }\n\n        break;\n\n      case 'meta':\n        for (var i = 0, len = METATYPES.length; i < len; i++) {\n          var metatype = METATYPES[i];\n          if (!h.props.hasOwnProperty(metatype)) continue;\n\n          if (metatype === 'charSet') {\n            if (metaTypes.has(metatype)) {\n              isUnique = false;\n            } else {\n              metaTypes.add(metatype);\n            }\n          } else {\n            var category = h.props[metatype];\n            var categories = metaCategories[metatype] || new Set();\n\n            if ((metatype !== 'name' || !hasKey) && categories.has(category)) {\n              isUnique = false;\n            } else {\n              categories.add(category);\n              metaCategories[metatype] = categories;\n            }\n          }\n        }\n\n        break;\n    }\n\n    return isUnique;\n  };\n}\n/**\n *\n * @param headChildrenElements List of children of <Head>\n */\n\n\nfunction reduceComponents(headChildrenElements, props) {\n  return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(props.inAmpMode).reverse()).filter(unique()).reverse().map(function (c, i) {\n    var key = c.key || i;\n\n    if (false) { var newProps; }\n\n    if (false) { var srcMessage; }\n\n    return /*#__PURE__*/_react.default.cloneElement(c, {\n      key: key\n    });\n  });\n}\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */\n\n\nfunction Head(_ref) {\n  _s();\n\n  var children = _ref.children;\n  var ampState = (0, _react).useContext(_ampContext.AmpStateContext);\n  var headManager = (0, _react).useContext(_headManagerContext.HeadManagerContext);\n  return /*#__PURE__*/_react.default.createElement(_sideEffect.default, {\n    reduceComponentsToState: reduceComponents,\n    headManager: headManager,\n    inAmpMode: (0, _ampMode).isInAmpMode(ampState)\n  }, children);\n}\n\n_s(Head, \"sCUayZmr5V93tUjujy03KdMBCec=\");\n\n_c = Head;\nvar _default = Head;\nexports[\"default\"] = _default;\n\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', {\n    value: true\n  });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"Head\");\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaGVhZC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7OztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQURrQyxDQUE3QztBQUdBRCxtQkFBQSxHQUFzQkUsV0FBdEI7QUFDQUYsa0JBQUEsR0FBa0IsS0FBSyxDQUF2Qjs7QUFDQSxJQUFJSSxNQUFNLEdBQUdDLHVCQUF1QixDQUFDQyxtQkFBTyxDQUFDLDRDQUFELENBQVIsQ0FBcEM7O0FBQ0EsSUFBSUMsV0FBVyxHQUFHQyxzQkFBc0IsQ0FBQ0YsbUJBQU8sQ0FBQyx5RUFBRCxDQUFSLENBQXhDOztBQUNBLElBQUlHLFdBQVcsR0FBR0gsbUJBQU8sQ0FBQyx5RUFBRCxDQUF6Qjs7QUFDQSxJQUFJSSxtQkFBbUIsR0FBR0osbUJBQU8sQ0FBQywyRkFBRCxDQUFqQzs7QUFDQSxJQUFJSyxRQUFRLEdBQUdMLG1CQUFPLENBQUMsbUVBQUQsQ0FBdEI7O0FBQ0EsSUFBSU0sTUFBTSxHQUFHTixtQkFBTyxDQUFDLDZEQUFELENBQXBCOztBQUNBLFNBQVNPLFFBQVQsR0FBb0I7RUFDaEJBLFFBQVEsR0FBR2YsTUFBTSxDQUFDZ0IsTUFBUCxJQUFpQixVQUFTQyxNQUFULEVBQWlCO0lBQ3pDLEtBQUksSUFBSUMsQ0FBQyxHQUFHLENBQVosRUFBZUEsQ0FBQyxHQUFHQyxTQUFTLENBQUNDLE1BQTdCLEVBQXFDRixDQUFDLEVBQXRDLEVBQXlDO01BQ3JDLElBQUlHLE1BQU0sR0FBR0YsU0FBUyxDQUFDRCxDQUFELENBQXRCOztNQUNBLEtBQUksSUFBSUksR0FBUixJQUFlRCxNQUFmLEVBQXNCO1FBQ2xCLElBQUlyQixNQUFNLENBQUN1QixTQUFQLENBQWlCQyxjQUFqQixDQUFnQ0MsSUFBaEMsQ0FBcUNKLE1BQXJDLEVBQTZDQyxHQUE3QyxDQUFKLEVBQXVEO1VBQ25ETCxNQUFNLENBQUNLLEdBQUQsQ0FBTixHQUFjRCxNQUFNLENBQUNDLEdBQUQsQ0FB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QyxPQUFPSCxPQUFPLENBQUNHLE9BQWYsS0FBMkIsUUFBM0IsSUFBdUNILE9BQU8sQ0FBQ0csT0FBUixLQUFvQixJQUF0RyxLQUFnSCxPQUFPSCxPQUFPLENBQUNHLE9BQVIsQ0FBZ0J1QixVQUF2QixLQUFzQyxXQUExSixFQUF1SztFQUNySzVCLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQkMsT0FBTyxDQUFDRyxPQUE5QixFQUF1QyxZQUF2QyxFQUFxRDtJQUFFRixLQUFLLEVBQUU7RUFBVCxDQUFyRDtFQUNBSCxNQUFNLENBQUNnQixNQUFQLENBQWNkLE9BQU8sQ0FBQ0csT0FBdEIsRUFBK0JILE9BQS9CO0VBQ0FxRyxNQUFNLENBQUNyRyxPQUFQLEdBQWlCQSxPQUFPLENBQUNHLE9BQXpCO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2hlYWQuanM/ZmI1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdEhlYWQgPSBkZWZhdWx0SGVhZDtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9zaWRlRWZmZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zaWRlLWVmZmVjdFwiKSk7XG52YXIgX2FtcENvbnRleHQgPSByZXF1aXJlKFwiLi9hbXAtY29udGV4dFwiKTtcbnZhciBfaGVhZE1hbmFnZXJDb250ZXh0ID0gcmVxdWlyZShcIi4vaGVhZC1tYW5hZ2VyLWNvbnRleHRcIik7XG52YXIgX2FtcE1vZGUgPSByZXF1aXJlKFwiLi9hbXAtbW9kZVwiKTtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gc291cmNlKXtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7XG4gICAgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsO1xuICAgIHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9O1xuICAgIHJldHVybiBjYWNoZTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICAgIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpO1xuICAgIGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkge1xuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KG9iaik7XG4gICAgfVxuICAgIHZhciBuZXdPYmogPSB7fTtcbiAgICB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgZm9yKHZhciBrZXkgaW4gb2JqKXtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV3T2JqLmRlZmF1bHQgPSBvYmo7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGNhY2hlLnNldChvYmosIG5ld09iaik7XG4gICAgfVxuICAgIHJldHVybiBuZXdPYmo7XG59XG5mdW5jdGlvbiBkZWZhdWx0SGVhZChpbkFtcE1vZGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGhlYWQgPSBbXG4gICAgICAgIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICAgICAgY2hhclNldDogXCJ1dGYtOFwiXG4gICAgICAgIH0pXG4gICAgXTtcbiAgICBpZiAoIWluQW1wTW9kZSkge1xuICAgICAgICBoZWFkLnB1c2goLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICAgICAgICBuYW1lOiBcInZpZXdwb3J0XCIsXG4gICAgICAgICAgICBjb250ZW50OiBcIndpZHRoPWRldmljZS13aWR0aFwiXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWQ7XG59XG5mdW5jdGlvbiBvbmx5UmVhY3RFbGVtZW50KGxpc3QsIGNoaWxkKSB7XG4gICAgLy8gUmVhY3QgY2hpbGRyZW4gY2FuIGJlIFwic3RyaW5nXCIgb3IgXCJudW1iZXJcIiBpbiB0aGlzIGNhc2Ugd2UgaWdub3JlIHRoZW0gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICAvLyBBZGRzIHN1cHBvcnQgZm9yIFJlYWN0LkZyYWdtZW50XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiBsaXN0LmNvbmNhdChfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkLnByb3BzLmNoaWxkcmVuKS5yZWR1Y2UoKGZyYWdtZW50TGlzdCwgZnJhZ21lbnRDaGlsZCk9PntcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnJhZ21lbnRDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGZyYWdtZW50Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50TGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3QuY29uY2F0KGZyYWdtZW50Q2hpbGQpO1xuICAgICAgICB9LCBbXSkpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdC5jb25jYXQoY2hpbGQpO1xufVxuY29uc3QgTUVUQVRZUEVTID0gW1xuICAgICduYW1lJyxcbiAgICAnaHR0cEVxdWl2JyxcbiAgICAnY2hhclNldCcsXG4gICAgJ2l0ZW1Qcm9wJ1xuXTtcbi8qXG4gcmV0dXJucyBhIGZ1bmN0aW9uIGZvciBmaWx0ZXJpbmcgaGVhZCBjaGlsZCBlbGVtZW50c1xuIHdoaWNoIHNob3VsZG4ndCBiZSBkdXBsaWNhdGVkLCBsaWtlIDx0aXRsZS8+XG4gQWxzbyBhZGRzIHN1cHBvcnQgZm9yIGRlZHVwbGljYXRlZCBga2V5YCBwcm9wZXJ0aWVzXG4qLyBmdW5jdGlvbiB1bmlxdWUoKSB7XG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB0YWdzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IG1ldGFUeXBlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBtZXRhQ2F0ZWdvcmllcyA9IHt9O1xuICAgIHJldHVybiAoaCk9PntcbiAgICAgICAgbGV0IGlzVW5pcXVlID0gdHJ1ZTtcbiAgICAgICAgbGV0IGhhc0tleSA9IGZhbHNlO1xuICAgICAgICBpZiAoaC5rZXkgJiYgdHlwZW9mIGgua2V5ICE9PSAnbnVtYmVyJyAmJiBoLmtleS5pbmRleE9mKCckJykgPiAwKSB7XG4gICAgICAgICAgICBoYXNLZXkgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gaC5rZXkuc2xpY2UoaC5rZXkuaW5kZXhPZignJCcpICsgMSk7XG4gICAgICAgICAgICBpZiAoa2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZVxuICAgICAgICBzd2l0Y2goaC50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgICAgICAgIGNhc2UgJ2Jhc2UnOlxuICAgICAgICAgICAgICAgIGlmICh0YWdzLmhhcyhoLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFncy5hZGQoaC50eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtZXRhJzpcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwLCBsZW4gPSBNRVRBVFlQRVMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhdHlwZSA9IE1FVEFUWVBFU1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoLnByb3BzLmhhc093blByb3BlcnR5KG1ldGF0eXBlKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhdHlwZSA9PT0gJ2NoYXJTZXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YVR5cGVzLmhhcyhtZXRhdHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhVHlwZXMuYWRkKG1ldGF0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gaC5wcm9wc1ttZXRhdHlwZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdIHx8IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobWV0YXR5cGUgIT09ICduYW1lJyB8fCAhaGFzS2V5KSAmJiBjYXRlZ29yaWVzLmhhcyhjYXRlZ29yeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzLmFkZChjYXRlZ29yeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdID0gY2F0ZWdvcmllcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNVbmlxdWU7XG4gICAgfTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBoZWFkQ2hpbGRyZW5FbGVtZW50cyBMaXN0IG9mIGNoaWxkcmVuIG9mIDxIZWFkPlxuICovIGZ1bmN0aW9uIHJlZHVjZUNvbXBvbmVudHMoaGVhZENoaWxkcmVuRWxlbWVudHMsIHByb3BzKSB7XG4gICAgcmV0dXJuIGhlYWRDaGlsZHJlbkVsZW1lbnRzLnJlZHVjZShvbmx5UmVhY3RFbGVtZW50LCBbXSkucmV2ZXJzZSgpLmNvbmNhdChkZWZhdWx0SGVhZChwcm9wcy5pbkFtcE1vZGUpLnJldmVyc2UoKSkuZmlsdGVyKHVuaXF1ZSgpKS5yZXZlcnNlKCkubWFwKChjLCBpKT0+e1xuICAgICAgICBjb25zdCBrZXkgPSBjLmtleSB8fCBpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiYgcHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVpFX0ZPTlRTICYmICFwcm9wcy5pbkFtcE1vZGUpIHtcbiAgICAgICAgICAgIGlmIChjLnR5cGUgPT09ICdsaW5rJyAmJiBjLnByb3BzWydocmVmJ10gJiYgLy8gVE9ETyhwcmF0ZWVrYmhAKTogUmVwbGFjZSB0aGlzIHdpdGggY29uc3QgZnJvbSBgY29uc3RhbnRzYCB3aGVuIHRoZSB0cmVlIHNoYWtpbmcgd29ya3MuXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzJyxcbiAgICAgICAgICAgICAgICAnaHR0cHM6Ly91c2UudHlwZWtpdC5uZXQvJ1xuICAgICAgICAgICAgXS5zb21lKCh1cmwpPT5jLnByb3BzWydocmVmJ10uc3RhcnRzV2l0aCh1cmwpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BzID0gX2V4dGVuZHMoe30sIGMucHJvcHMgfHwge30pO1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzWydkYXRhLWhyZWYnXSA9IG5ld1Byb3BzWydocmVmJ107XG4gICAgICAgICAgICAgICAgbmV3UHJvcHNbJ2hyZWYnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBhdHRyaWJ1dGUgdG8gbWFrZSBpdCBlYXN5IHRvIGlkZW50aWZ5IG9wdGltaXplZCB0YWdzXG4gICAgICAgICAgICAgICAgbmV3UHJvcHNbJ2RhdGEtb3B0aW1pemVkLWZvbnRzJ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNsb25lRWxlbWVudChjLCBuZXdQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIHByb2Nlc3MuZW52Ll9fTkVYVF9SRUFDVF9ST09UKSB7XG4gICAgICAgICAgICAvLyBvbWl0IEpTT04tTEQgc3RydWN0dXJlZCBkYXRhIHNuaXBwZXRzIGZyb20gdGhlIHdhcm5pbmdcbiAgICAgICAgICAgIGlmIChjLnR5cGUgPT09ICdzY3JpcHQnICYmIGMucHJvcHNbJ3R5cGUnXSAhPT0gJ2FwcGxpY2F0aW9uL2xkK2pzb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3JjTWVzc2FnZSA9IGMucHJvcHNbJ3NyYyddID8gYDxzY3JpcHQ+IHRhZyB3aXRoIHNyYz1cIiR7Yy5wcm9wc1snc3JjJ119XCJgIDogYGlubGluZSA8c2NyaXB0PmA7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYERvIG5vdCBhZGQgPHNjcmlwdD4gdGFncyB1c2luZyBuZXh0L2hlYWQgKHNlZSAke3NyY01lc3NhZ2V9KS4gVXNlIG5leHQvc2NyaXB0IGluc3RlYWQuIFxcblNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbm8tc2NyaXB0LXRhZ3MtaW4taGVhZC1jb21wb25lbnRgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYy50eXBlID09PSAnbGluaycgJiYgYy5wcm9wc1sncmVsJ10gPT09ICdzdHlsZXNoZWV0Jykge1xuICAgICAgICAgICAgICAgICgwLCBfdXRpbHMpLndhcm5PbmNlKGBEbyBub3QgYWRkIHN0eWxlc2hlZXRzIHVzaW5nIG5leHQvaGVhZCAoc2VlIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIj4gdGFnIHdpdGggaHJlZj1cIiR7Yy5wcm9wc1snaHJlZiddfVwiKS4gVXNlIERvY3VtZW50IGluc3RlYWQuIFxcblNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbm8tc3R5bGVzaGVldHMtaW4taGVhZC1jb21wb25lbnRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoYywge1xuICAgICAgICAgICAga2V5XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBpbmplY3RzIGVsZW1lbnRzIHRvIGA8aGVhZD5gIG9mIHlvdXIgcGFnZS5cbiAqIFRvIGF2b2lkIGR1cGxpY2F0ZWQgYHRhZ3NgIGluIGA8aGVhZD5gIHlvdSBjYW4gdXNlIHRoZSBga2V5YCBwcm9wZXJ0eSwgd2hpY2ggd2lsbCBtYWtlIHN1cmUgZXZlcnkgdGFnIGlzIG9ubHkgcmVuZGVyZWQgb25jZS5cbiAqLyBmdW5jdGlvbiBIZWFkKHsgY2hpbGRyZW4gIH0pIHtcbiAgICBjb25zdCBhbXBTdGF0ZSA9ICgwLCBfcmVhY3QpLnVzZUNvbnRleHQoX2FtcENvbnRleHQuQW1wU3RhdGVDb250ZXh0KTtcbiAgICBjb25zdCBoZWFkTWFuYWdlciA9ICgwLCBfcmVhY3QpLnVzZUNvbnRleHQoX2hlYWRNYW5hZ2VyQ29udGV4dC5IZWFkTWFuYWdlckNvbnRleHQpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3NpZGVFZmZlY3QuZGVmYXVsdCwge1xuICAgICAgICByZWR1Y2VDb21wb25lbnRzVG9TdGF0ZTogcmVkdWNlQ29tcG9uZW50cyxcbiAgICAgICAgaGVhZE1hbmFnZXI6IGhlYWRNYW5hZ2VyLFxuICAgICAgICBpbkFtcE1vZGU6ICgwLCBfYW1wTW9kZSkuaXNJbkFtcE1vZGUoYW1wU3RhdGUpXG4gICAgfSwgY2hpbGRyZW4pO1xufVxudmFyIF9kZWZhdWx0ID0gSGVhZDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWFkLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHRIZWFkIiwiZGVmYXVsdCIsIl9yZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9zaWRlRWZmZWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9hbXBDb250ZXh0IiwiX2hlYWRNYW5hZ2VyQ29udGV4dCIsIl9hbXBNb2RlIiwiX3V0aWxzIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiV2Vha01hcCIsImNhY2hlIiwiaGFzIiwiZ2V0IiwibmV3T2JqIiwiaGFzUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZGVzYyIsInNldCIsImluQW1wTW9kZSIsImhlYWQiLCJjcmVhdGVFbGVtZW50IiwiY2hhclNldCIsInB1c2giLCJuYW1lIiwiY29udGVudCIsIm9ubHlSZWFjdEVsZW1lbnQiLCJsaXN0IiwiY2hpbGQiLCJ0eXBlIiwiRnJhZ21lbnQiLCJjb25jYXQiLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJwcm9wcyIsImNoaWxkcmVuIiwicmVkdWNlIiwiZnJhZ21lbnRMaXN0IiwiZnJhZ21lbnRDaGlsZCIsIk1FVEFUWVBFUyIsInVuaXF1ZSIsImtleXMiLCJTZXQiLCJ0YWdzIiwibWV0YVR5cGVzIiwibWV0YUNhdGVnb3JpZXMiLCJoIiwiaXNVbmlxdWUiLCJoYXNLZXkiLCJpbmRleE9mIiwic2xpY2UiLCJhZGQiLCJsZW4iLCJtZXRhdHlwZSIsImNhdGVnb3J5IiwiY2F0ZWdvcmllcyIsInJlZHVjZUNvbXBvbmVudHMiLCJoZWFkQ2hpbGRyZW5FbGVtZW50cyIsInJldmVyc2UiLCJmaWx0ZXIiLCJtYXAiLCJjIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9PUFRJTUlaRV9GT05UUyIsInNvbWUiLCJ1cmwiLCJzdGFydHNXaXRoIiwibmV3UHJvcHMiLCJ1bmRlZmluZWQiLCJjbG9uZUVsZW1lbnQiLCJfX05FWFRfUkVBQ1RfUk9PVCIsInNyY01lc3NhZ2UiLCJ3YXJuT25jZSIsIkhlYWQiLCJhbXBTdGF0ZSIsInVzZUNvbnRleHQiLCJBbXBTdGF0ZUNvbnRleHQiLCJoZWFkTWFuYWdlciIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsInJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIiwiaXNJbkFtcE1vZGUiLCJfZGVmYXVsdCIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/head.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/side-effect.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/side-effect.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\n\nvar _s = $RefreshSig$();\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = SideEffect;\n\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nfunction SideEffect(props) {\n  _s();\n\n  var headManager = props.headManager,\n      reduceComponentsToState = props.reduceComponentsToState;\n\n  function emitChange() {\n    if (headManager && headManager.mountedInstances) {\n      var headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n\n      headManager.updateHead(reduceComponentsToState(headElements, props));\n    }\n  }\n\n  if (isServer) {\n    var ref;\n    headManager == null ? void 0 : (ref = headManager.mountedInstances) == null ? void 0 : ref.add(props.children);\n    emitChange();\n  }\n\n  useClientOnlyLayoutEffect(function () {\n    var ref1;\n    headManager == null ? void 0 : (ref1 = headManager.mountedInstances) == null ? void 0 : ref1.add(props.children);\n    return function () {\n      var ref;\n      headManager == null ? void 0 : (ref = headManager.mountedInstances) == null ? void 0 : ref.delete(props.children);\n    };\n  }); // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n  // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n  // being rendered, we only trigger the method from the last one.\n  // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n  // singleton in the layout effect pass, and actually trigger it in the effect pass.\n\n  useClientOnlyLayoutEffect(function () {\n    if (headManager) {\n      headManager._pendingUpdate = emitChange;\n    }\n\n    return function () {\n      if (headManager) {\n        headManager._pendingUpdate = emitChange;\n      }\n    };\n  });\n  useClientOnlyEffect(function () {\n    if (headManager && headManager._pendingUpdate) {\n      headManager._pendingUpdate();\n\n      headManager._pendingUpdate = null;\n    }\n\n    return function () {\n      if (headManager && headManager._pendingUpdate) {\n        headManager._pendingUpdate();\n\n        headManager._pendingUpdate = null;\n      }\n    };\n  });\n  return null;\n}\n\n_s(SideEffect, \"gHVkikNHNxjVdD11eJBzaqkCiPY=\", false, function () {\n  return [useClientOnlyLayoutEffect, useClientOnlyLayoutEffect, useClientOnlyEffect];\n});\n\n_c = SideEffect;\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar isServer = false;\nvar useClientOnlyLayoutEffect = isServer ? function () {} : _react.useLayoutEffect;\nvar useClientOnlyEffect = isServer ? function () {} : _react.useEffect;\n\nvar _c;\n\n$RefreshReg$(_c, \"SideEffect\");\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvc2lkZS1lZmZlY3QuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7Ozs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0M7QUFHQUQsa0JBQUEsR0FBa0JHLFVBQWxCOztBQUNBLElBQUlDLE1BQU0sR0FBR0MsdUJBQXVCLENBQUNDLG1CQUFPLENBQUMsNENBQUQsQ0FBUixDQUFwQzs7QUFDQSxTQUFTSCxVQUFULENBQW9CSSxLQUFwQixFQUEyQjtFQUFBOztFQUN2QixJQUFRQyxXQUFSLEdBQW1ERCxLQUFuRCxDQUFRQyxXQUFSO0VBQUEsSUFBc0JDLHVCQUF0QixHQUFtREYsS0FBbkQsQ0FBc0JFLHVCQUF0Qjs7RUFDQSxTQUFTQyxVQUFULEdBQXNCO0lBQ2xCLElBQUlGLFdBQVcsSUFBSUEsV0FBVyxDQUFDRyxnQkFBL0IsRUFBaUQ7TUFDN0MsSUFBTUMsWUFBWSxHQUFHUixNQUFNLENBQUNTLFFBQVAsQ0FBZ0JDLE9BQWhCLENBQXdCQyxLQUFLLENBQUNDLElBQU4sQ0FBV1IsV0FBVyxDQUFDRyxnQkFBdkIsRUFBeUNNLE1BQXpDLENBQWdEQyxPQUFoRCxDQUF4QixDQUFyQjs7TUFDQVYsV0FBVyxDQUFDVyxVQUFaLENBQXVCVix1QkFBdUIsQ0FBQ0csWUFBRCxFQUFlTCxLQUFmLENBQTlDO0lBQ0g7RUFDSjs7RUFDRCxJQUFJYSxRQUFKLEVBQWM7SUFDVixJQUFJQyxHQUFKO0lBQ0FiLFdBQVcsSUFBSSxJQUFmLEdBQXNCLEtBQUssQ0FBM0IsR0FBK0IsQ0FBQ2EsR0FBRyxHQUFHYixXQUFXLENBQUNHLGdCQUFuQixLQUF3QyxJQUF4QyxHQUErQyxLQUFLLENBQXBELEdBQXdEVSxHQUFHLENBQUNDLEdBQUosQ0FBUWYsS0FBSyxDQUFDZ0IsUUFBZCxDQUF2RjtJQUNBYixVQUFVO0VBQ2I7O0VBQ0RjLHlCQUF5QixDQUFDLFlBQUk7SUFDMUIsSUFBSUMsSUFBSjtJQUNBakIs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LEdBQUd2QyxNQUFNLENBQUN3Qyx3QkFBUCxDQUFnQ04sR0FBaEMsRUFBcUNPLEdBQXJDLENBQUgsR0FBK0MsSUFBL0U7O01BQ0EsSUFBSUksSUFBSSxLQUFLQSxJQUFJLENBQUNSLEdBQUwsSUFBWVEsSUFBSSxDQUFDQyxHQUF0QixDQUFSLEVBQW9DO1FBQ2hDOUMsTUFBTSxDQUFDQyxjQUFQLENBQXNCcUMsTUFBdEIsRUFBOEJHLEdBQTlCLEVBQW1DSSxJQUFuQztNQUNILENBRkQsTUFFTztRQUNIUCxNQUFNLENBQUNHLEdBQUQsQ0FBTixHQUFjUCxHQUFHLENBQUNPLEdBQUQsQ0FBakI7TUFDSDtJQUNKO0VBQ0o7O0VBQ0RILE1BQU0sQ0FBQ2xDLE9BQVAsR0FBaUI4QixHQUFqQjs7RUFDQSxJQUFJRCxLQUFKLEVBQVc7SUFDUEEsS0FBSyxDQUFDYSxHQUFOLENBQVVaLEdBQVYsRUFBZUksTUFBZjtFQUNIOztFQUNELE9BQU9BLE1BQVA7QUFDSDs7QUFDRCxJQUFNaEIsUUFBUSxRQUFkO0FBQ0EsSUFBTUkseUJBQXlCLEdBQUdKLFFBQVEsR0FBRyxZQUFJLENBQUUsQ0FBVCxHQUFZaEIsTUFBTSxDQUFDeUMsZUFBN0Q7QUFDQSxJQUFNakIsbUJBQW1CLEdBQUdSLFFBQVEsR0FBRyxZQUFJLENBQUUsQ0FBVCxHQUFZaEIsTUFBTSxDQUFDMEMsU0FBdkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3NpZGUtZWZmZWN0LmpzPzQwOGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTaWRlRWZmZWN0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5mdW5jdGlvbiBTaWRlRWZmZWN0KHByb3BzKSB7XG4gICAgY29uc3QgeyBoZWFkTWFuYWdlciAsIHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlICB9ID0gcHJvcHM7XG4gICAgZnVuY3Rpb24gZW1pdENoYW5nZSgpIHtcbiAgICAgICAgaWYgKGhlYWRNYW5hZ2VyICYmIGhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRFbGVtZW50cyA9IF9yZWFjdC5DaGlsZHJlbi50b0FycmF5KEFycmF5LmZyb20oaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcykuZmlsdGVyKEJvb2xlYW4pKTtcbiAgICAgICAgICAgIGhlYWRNYW5hZ2VyLnVwZGF0ZUhlYWQocmVkdWNlQ29tcG9uZW50c1RvU3RhdGUoaGVhZEVsZW1lbnRzLCBwcm9wcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc1NlcnZlcikge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICBoZWFkTWFuYWdlciA9PSBudWxsID8gdm9pZCAwIDogKHJlZiA9IGhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMpID09IG51bGwgPyB2b2lkIDAgOiByZWYuYWRkKHByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgZW1pdENoYW5nZSgpO1xuICAgIH1cbiAgICB1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIHZhciByZWYxO1xuICAgICAgICBoZWFkTWFuYWdlciA9PSBudWxsID8gdm9pZCAwIDogKHJlZjEgPSBoZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzKSA9PSBudWxsID8gdm9pZCAwIDogcmVmMS5hZGQocHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICBoZWFkTWFuYWdlciA9PSBudWxsID8gdm9pZCAwIDogKHJlZiA9IGhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMpID09IG51bGwgPyB2b2lkIDAgOiByZWYuZGVsZXRlKHByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICAvLyBXZSBuZWVkIHRvIGNhbGwgYHVwZGF0ZUhlYWRgIG1ldGhvZCB3aGVuZXZlciB0aGUgYFNpZGVFZmZlY3RgIGlzIHRyaWdnZXIgaW4gYWxsXG4gICAgLy8gbGlmZS1jeWNsZXM6IG1vdW50LCB1cGRhdGUsIHVubW91bnQuIEhvd2V2ZXIsIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBgU2lkZUVmZmVjdGBzXG4gICAgLy8gYmVpbmcgcmVuZGVyZWQsIHdlIG9ubHkgdHJpZ2dlciB0aGUgbWV0aG9kIGZyb20gdGhlIGxhc3Qgb25lLlxuICAgIC8vIFRoaXMgaXMgZW5zdXJlZCBieSBrZWVwaW5nIHRoZSBsYXN0IHVuZmx1c2hlZCBgdXBkYXRlSGVhZGAgaW4gdGhlIGBfcGVuZGluZ1VwZGF0ZWBcbiAgICAvLyBzaW5nbGV0b24gaW4gdGhlIGxheW91dCBlZmZlY3QgcGFzcywgYW5kIGFjdHVhbGx5IHRyaWdnZXIgaXQgaW4gdGhlIGVmZmVjdCBwYXNzLlxuICAgIHVzZUNsaWVudE9ubHlMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKGhlYWRNYW5hZ2VyKSB7XG4gICAgICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IGVtaXRDaGFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpZiAoaGVhZE1hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IGVtaXRDaGFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgdXNlQ2xpZW50T25seUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoaGVhZE1hbmFnZXIgJiYgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUpIHtcbiAgICAgICAgICAgIGhlYWRNYW5hZ2VyLl9wZW5kaW5nVXBkYXRlKCk7XG4gICAgICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpZiAoaGVhZE1hbmFnZXIgJiYgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIGhlYWRNYW5hZ2VyLl9wZW5kaW5nVXBkYXRlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgICBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7XG4gICAgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbiAgICBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH07XG4gICAgcmV0dXJuIGNhY2hlO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7XG4gICAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7XG4gICAgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5nZXQob2JqKTtcbiAgICB9XG4gICAgdmFyIG5ld09iaiA9IHt9O1xuICAgIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICBmb3IodmFyIGtleSBpbiBvYmope1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXdPYmouZGVmYXVsdCA9IG9iajtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld09iajtcbn1cbmNvbnN0IGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG5jb25zdCB1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0ID0gaXNTZXJ2ZXIgPyAoKT0+e30gOiBfcmVhY3QudXNlTGF5b3V0RWZmZWN0O1xuY29uc3QgdXNlQ2xpZW50T25seUVmZmVjdCA9IGlzU2VydmVyID8gKCk9Pnt9IDogX3JlYWN0LnVzZUVmZmVjdDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lkZS1lZmZlY3QuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIlNpZGVFZmZlY3QiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJwcm9wcyIsImhlYWRNYW5hZ2VyIiwicmVkdWNlQ29tcG9uZW50c1RvU3RhdGUiLCJlbWl0Q2hhbmdlIiwibW91bnRlZEluc3RhbmNlcyIsImhlYWRFbGVtZW50cyIsIkNoaWxkcmVuIiwidG9BcnJheSIsIkFycmF5IiwiZnJvbSIsImZpbHRlciIsIkJvb2xlYW4iLCJ1cGRhdGVIZWFkIiwiaXNTZXJ2ZXIiLCJyZWYiLCJhZGQiLCJjaGlsZHJlbiIsInVzZUNsaWVudE9ubHlMYXlvdXRFZmZlY3QiLCJyZWYxIiwiZGVsZXRlIiwiX3BlbmRpbmdVcGRhdGUiLCJ1c2VDbGllbnRPbmx5RWZmZWN0IiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwiV2Vha01hcCIsImNhY2hlIiwib2JqIiwiX19lc01vZHVsZSIsImhhcyIsImdldCIsIm5ld09iaiIsImhhc1Byb3BlcnR5RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImRlc2MiLCJzZXQiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/side-effect.js\n"));

/***/ })

}]);