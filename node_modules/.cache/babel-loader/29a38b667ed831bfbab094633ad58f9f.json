{"ast":null,"code":"/*!\nFullCalendar v5.10.1\nDocs & License: https://fullcalendar.io/\n(c) 2021 Adam Shaw\n*/\nimport { __assign } from 'tslib';\nimport { identity, createPlugin, requestJson, addDays } from '@fullcalendar/common'; // rename this file to options.ts like other packages?\n\nvar OPTION_REFINERS = {\n  googleCalendarApiKey: String\n};\nvar EVENT_SOURCE_REFINERS = {\n  googleCalendarApiKey: String,\n  googleCalendarId: String,\n  googleCalendarApiBase: String,\n  extraParams: identity\n}; // TODO: expose somehow\n\nvar API_BASE = 'https://www.googleapis.com/calendar/v3/calendars';\nvar eventSourceDef = {\n  parseMeta: function parseMeta(refined) {\n    var googleCalendarId = refined.googleCalendarId;\n\n    if (!googleCalendarId && refined.url) {\n      googleCalendarId = parseGoogleCalendarId(refined.url);\n    }\n\n    if (googleCalendarId) {\n      return {\n        googleCalendarId: googleCalendarId,\n        googleCalendarApiKey: refined.googleCalendarApiKey,\n        googleCalendarApiBase: refined.googleCalendarApiBase,\n        extraParams: refined.extraParams\n      };\n    }\n\n    return null;\n  },\n  fetch: function fetch(arg, onSuccess, onFailure) {\n    var _a = arg.context,\n        dateEnv = _a.dateEnv,\n        options = _a.options;\n    var meta = arg.eventSource.meta;\n    var apiKey = meta.googleCalendarApiKey || options.googleCalendarApiKey;\n\n    if (!apiKey) {\n      onFailure({\n        message: 'Specify a googleCalendarApiKey. See http://fullcalendar.io/docs/google_calendar/'\n      });\n    } else {\n      var url = buildUrl(meta); // TODO: make DRY with json-feed-event-source\n\n      var extraParams = meta.extraParams;\n      var extraParamsObj = typeof extraParams === 'function' ? extraParams() : extraParams;\n      var requestParams_1 = buildRequestParams(arg.range, apiKey, extraParamsObj, dateEnv);\n      requestJson('GET', url, requestParams_1, function (body, xhr) {\n        if (body.error) {\n          onFailure({\n            message: 'Google Calendar API: ' + body.error.message,\n            errors: body.error.errors,\n            xhr: xhr\n          });\n        } else {\n          onSuccess({\n            rawEvents: gcalItemsToRawEventDefs(body.items, requestParams_1.timeZone),\n            xhr: xhr\n          });\n        }\n      }, function (message, xhr) {\n        onFailure({\n          message: message,\n          xhr: xhr\n        });\n      });\n    }\n  }\n};\n\nfunction parseGoogleCalendarId(url) {\n  var match; // detect if the ID was specified as a single string.\n  // will match calendars like \"asdf1234@calendar.google.com\" in addition to person email calendars.\n\n  if (/^[^/]+@([^/.]+\\.)*(google|googlemail|gmail)\\.com$/.test(url)) {\n    return url;\n  }\n\n  if ((match = /^https:\\/\\/www.googleapis.com\\/calendar\\/v3\\/calendars\\/([^/]*)/.exec(url)) || (match = /^https?:\\/\\/www.google.com\\/calendar\\/feeds\\/([^/]*)/.exec(url))) {\n    return decodeURIComponent(match[1]);\n  }\n\n  return null;\n}\n\nfunction buildUrl(meta) {\n  var apiBase = meta.googleCalendarApiBase;\n\n  if (!apiBase) {\n    apiBase = API_BASE;\n  }\n\n  return apiBase + '/' + encodeURIComponent(meta.googleCalendarId) + '/events';\n}\n\nfunction buildRequestParams(range, apiKey, extraParams, dateEnv) {\n  var params;\n  var startStr;\n  var endStr;\n\n  if (dateEnv.canComputeOffset) {\n    // strings will naturally have offsets, which GCal needs\n    startStr = dateEnv.formatIso(range.start);\n    endStr = dateEnv.formatIso(range.end);\n  } else {\n    // when timezone isn't known, we don't know what the UTC offset should be, so ask for +/- 1 day\n    // from the UTC day-start to guarantee we're getting all the events\n    // (start/end will be UTC-coerced dates, so toISOString is okay)\n    startStr = addDays(range.start, -1).toISOString();\n    endStr = addDays(range.end, 1).toISOString();\n  }\n\n  params = __assign(__assign({}, extraParams || {}), {\n    key: apiKey,\n    timeMin: startStr,\n    timeMax: endStr,\n    singleEvents: true,\n    maxResults: 9999\n  });\n\n  if (dateEnv.timeZone !== 'local') {\n    params.timeZone = dateEnv.timeZone;\n  }\n\n  return params;\n}\n\nfunction gcalItemsToRawEventDefs(items, gcalTimezone) {\n  return items.map(function (item) {\n    return gcalItemToRawEventDef(item, gcalTimezone);\n  });\n}\n\nfunction gcalItemToRawEventDef(item, gcalTimezone) {\n  var url = item.htmlLink || null; // make the URLs for each event show times in the correct timezone\n\n  if (url && gcalTimezone) {\n    url = injectQsComponent(url, 'ctz=' + gcalTimezone);\n  }\n\n  return {\n    id: item.id,\n    title: item.summary,\n    start: item.start.dateTime || item.start.date,\n    end: item.end.dateTime || item.end.date,\n    url: url,\n    location: item.location,\n    description: item.description,\n    attachments: item.attachments || [],\n    extendedProps: (item.extendedProperties || {}).shared || {}\n  };\n} // Injects a string like \"arg=value\" into the querystring of a URL\n// TODO: move to a general util file?\n\n\nfunction injectQsComponent(url, component) {\n  // inject it after the querystring but before the fragment\n  return url.replace(/(\\?.*?)?(#|$)/, function (whole, qs, hash) {\n    return (qs ? qs + '&' : '?') + component + hash;\n  });\n}\n\nvar main = createPlugin({\n  eventSourceDefs: [eventSourceDef],\n  optionRefiners: OPTION_REFINERS,\n  eventSourceRefiners: EVENT_SOURCE_REFINERS\n});\nexport default main;","map":{"version":3,"sources":["src/options-refiners.ts","src/event-source-refiners.ts","src/main.ts"],"names":[],"mappings":"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","sourcesContent":["// rename this file to options.ts like other packages?\n\nexport const OPTION_REFINERS = {\n  googleCalendarApiKey: String,\n}\n","import { identity, Identity, Dictionary } from '@fullcalendar/common'\n\nexport const EVENT_SOURCE_REFINERS = {\n  googleCalendarApiKey: String, // TODO: rename with no prefix?\n  googleCalendarId: String,\n  googleCalendarApiBase: String,\n  extraParams: identity as Identity<Dictionary | (() => Dictionary)>,\n}\n","import { createPlugin, EventSourceDef, addDays, DateEnv, requestJson, Dictionary } from '@fullcalendar/common'\nimport { OPTION_REFINERS } from './options-refiners'\nimport './options-declare'\nimport { EVENT_SOURCE_REFINERS } from './event-source-refiners'\nimport './event-source-declare'\n\n// TODO: expose somehow\nconst API_BASE = 'https://www.googleapis.com/calendar/v3/calendars'\n\ninterface GCalMeta {\n  googleCalendarId: string\n  googleCalendarApiKey?: string\n  googleCalendarApiBase?: string,\n  extraParams?: Dictionary | (() => Dictionary)\n}\n\nlet eventSourceDef: EventSourceDef<GCalMeta> = {\n\n  parseMeta(refined): GCalMeta | null {\n    let { googleCalendarId } = refined\n\n    if (!googleCalendarId && refined.url) {\n      googleCalendarId = parseGoogleCalendarId(refined.url)\n    }\n\n    if (googleCalendarId) {\n      return {\n        googleCalendarId,\n        googleCalendarApiKey: refined.googleCalendarApiKey,\n        googleCalendarApiBase: refined.googleCalendarApiBase,\n        extraParams: refined.extraParams,\n      }\n    }\n\n    return null\n  },\n\n  fetch(arg, onSuccess, onFailure) {\n    let { dateEnv, options } = arg.context\n    let meta: GCalMeta = arg.eventSource.meta\n    let apiKey = meta.googleCalendarApiKey || options.googleCalendarApiKey\n\n    if (!apiKey) {\n      onFailure({\n        message: 'Specify a googleCalendarApiKey. See http://fullcalendar.io/docs/google_calendar/',\n      })\n    } else {\n      let url = buildUrl(meta)\n\n      // TODO: make DRY with json-feed-event-source\n      let { extraParams } = meta\n      let extraParamsObj = typeof extraParams === 'function' ? extraParams() : extraParams\n\n      let requestParams = buildRequestParams(\n        arg.range,\n        apiKey,\n        extraParamsObj,\n        dateEnv,\n      )\n\n      requestJson('GET', url, requestParams, (body, xhr) => {\n        if (body.error) {\n          onFailure({\n            message: 'Google Calendar API: ' + body.error.message,\n            errors: body.error.errors,\n            xhr,\n          })\n        } else {\n          onSuccess({\n            rawEvents: gcalItemsToRawEventDefs(\n              body.items,\n              requestParams.timeZone,\n            ),\n            xhr,\n          })\n        }\n      }, (message, xhr) => {\n        onFailure({ message, xhr })\n      })\n    }\n  },\n}\n\nfunction parseGoogleCalendarId(url) {\n  let match\n\n  // detect if the ID was specified as a single string.\n  // will match calendars like \"asdf1234@calendar.google.com\" in addition to person email calendars.\n  if (/^[^/]+@([^/.]+\\.)*(google|googlemail|gmail)\\.com$/.test(url)) {\n    return url\n  }\n\n  if (\n    (match = /^https:\\/\\/www.googleapis.com\\/calendar\\/v3\\/calendars\\/([^/]*)/.exec(url)) ||\n    (match = /^https?:\\/\\/www.google.com\\/calendar\\/feeds\\/([^/]*)/.exec(url))\n  ) {\n    return decodeURIComponent(match[1])\n  }\n\n  return null\n}\n\nfunction buildUrl(meta) {\n  let apiBase = meta.googleCalendarApiBase\n  if (!apiBase) {\n    apiBase = API_BASE\n  }\n  return apiBase + '/' + encodeURIComponent(meta.googleCalendarId) + '/events'\n}\n\nfunction buildRequestParams(range, apiKey: string, extraParams: Dictionary, dateEnv: DateEnv) {\n  let params\n  let startStr\n  let endStr\n\n  if (dateEnv.canComputeOffset) {\n    // strings will naturally have offsets, which GCal needs\n    startStr = dateEnv.formatIso(range.start)\n    endStr = dateEnv.formatIso(range.end)\n  } else {\n    // when timezone isn't known, we don't know what the UTC offset should be, so ask for +/- 1 day\n    // from the UTC day-start to guarantee we're getting all the events\n    // (start/end will be UTC-coerced dates, so toISOString is okay)\n    startStr = addDays(range.start, -1).toISOString()\n    endStr = addDays(range.end, 1).toISOString()\n  }\n\n  params = {\n    ...(extraParams || {}),\n    key: apiKey,\n    timeMin: startStr,\n    timeMax: endStr,\n    singleEvents: true,\n    maxResults: 9999,\n  }\n\n  if (dateEnv.timeZone !== 'local') {\n    params.timeZone = dateEnv.timeZone\n  }\n\n  return params\n}\n\nfunction gcalItemsToRawEventDefs(items, gcalTimezone) {\n  return items.map((item) => gcalItemToRawEventDef(item, gcalTimezone))\n}\n\nfunction gcalItemToRawEventDef(item, gcalTimezone) {\n  let url = item.htmlLink || null\n\n  // make the URLs for each event show times in the correct timezone\n  if (url && gcalTimezone) {\n    url = injectQsComponent(url, 'ctz=' + gcalTimezone)\n  }\n\n  return {\n    id: item.id,\n    title: item.summary,\n    start: item.start.dateTime || item.start.date, // try timed. will fall back to all-day\n    end: item.end.dateTime || item.end.date, // same\n    url,\n    location: item.location,\n    description: item.description,\n    attachments: item.attachments || [],\n    extendedProps: (item.extendedProperties || {}).shared || {},\n  }\n}\n\n// Injects a string like \"arg=value\" into the querystring of a URL\n// TODO: move to a general util file?\nfunction injectQsComponent(url, component) {\n  // inject it after the querystring but before the fragment\n  return url.replace(\n    /(\\?.*?)?(#|$)/,\n    (whole, qs, hash) => (qs ? qs + '&' : '?') + component + hash,\n  )\n}\n\nexport default createPlugin({\n  eventSourceDefs: [eventSourceDef],\n  optionRefiners: OPTION_REFINERS,\n  eventSourceRefiners: EVENT_SOURCE_REFINERS,\n})\n"]},"metadata":{},"sourceType":"module"}